'use client';

import { useState, useEffect, useCallback } from 'react';
import type { ConversationSummary } from '@/types/summary';

interface UseSummaryOptions {
  conversationId: string | null;
  autoGenerate?: boolean;
  autoGenerateDelay?: number; // milliseconds to wait before auto-generating
}

export function useSummary({
  conversationId,
  autoGenerate = true,
  autoGenerateDelay = 600000, // 10 minutes default
}: UseSummaryOptions) {
  const [summary, setSummary] = useState<ConversationSummary | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showFullPanel, setShowFullPanel] = useState(false);

  // Fetch existing summary
  const fetchSummary = useCallback(async () => {
    if (!conversationId) return;

    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/conversations/${conversationId}/summarize`);
      
      if (response.status === 404) {
        // No summary exists yet
        setSummary(null);
        return;
      }

      if (!response.ok) {
        throw new Error('Failed to fetch summary');
      }

      const data = await response.json();
      setSummary(data.summary);
    } catch (err) {
      // Don't log 404s - they're expected for new conversations
      if (err instanceof Error && !err.message.includes('404')) {
        console.error('Fetch summary error:', err);
      }
      setError(err instanceof Error ? err.message : 'Unknown error');
      setSummary(null);
    } finally {
      setIsLoading(false);
    }
  }, [conversationId]);

  // Generate new summary
  const generateSummary = useCallback(async (forceRegenerate = false) => {
    if (!conversationId) return;

    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/conversations/${conversationId}/summarize`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ forceRegenerate }),
      });

      if (!response.ok) {
        throw new Error('Failed to generate summary');
      }

      const data = await response.json();
      setSummary(data.summary);
      return data.summary;
    } catch (err) {
      // Only log unexpected errors
      if (err instanceof Error && !err.message.includes('empty conversation')) {
        console.error('Generate summary error:', err);
      }
      setError(err instanceof Error ? err.message : 'Unknown error');
      setSummary(null);
    } finally {
      setIsLoading(false);
    }
  }, [conversationId]);

  // Export summary as markdown
  const exportAsMarkdown = useCallback(() => {
    if (!summary) return;

    const markdown = `# Conversation Summary

**Generated:** ${new Date(summary.generatedAt).toLocaleString()}  
**Messages:** ${summary.messageCount}

## Overview
${summary.summary}

## Key Points
${summary.keyPoints.map((point, i) => `${i + 1}. ${point}`).join('\n')}

## Topics Discussed
${summary.topics.map(topic => `- ${topic}`).join('\n')}

${summary.importantMoments.length > 0 ? `## Important Moments
${summary.importantMoments.map(moment => `### ${moment.type.toUpperCase()}
- **Time:** ${new Date(moment.timestamp).toLocaleString()}
- **Description:** ${moment.description}
`).join('\n')}` : ''}

${summary.outcome ? `## Outcome
${summary.outcome}` : ''}

${summary.progress !== null && summary.progress !== undefined ? `## Progress
Completion: ${Math.round(summary.progress * 100)}%` : ''}
`;

    // Create blob and download
    const blob = new Blob([markdown], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `conversation-summary-${conversationId}.md`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, [summary, conversationId]);

  // Open/close full panel
  const openFullPanel = useCallback(() => setShowFullPanel(true), []);
  const closeFullPanel = useCallback(() => setShowFullPanel(false), []);

  // Auto-fetch summary when conversation changes
  useEffect(() => {
    if (conversationId) {
      fetchSummary();
    } else {
      setSummary(null);
    }
  }, [conversationId, fetchSummary]);

  // Auto-generate summary after delay (simulating "conversation idle")
  useEffect(() => {
    if (!autoGenerate || !conversationId || summary) return;

    const timer = setTimeout(() => {
      generateSummary(false);
    }, autoGenerateDelay);

    return () => clearTimeout(timer);
  }, [autoGenerate, conversationId, summary, autoGenerateDelay, generateSummary]);

  return {
    summary,
    isLoading,
    error,
    showFullPanel,
    fetchSummary,
    generateSummary,
    exportAsMarkdown,
    openFullPanel,
    closeFullPanel,
  };
}
